#!/usr/bin/python
import sys
import collections
from numpy import random
from functools import partial
from multiprocessing import Pool
from math import factorial as fac
from bisect import bisect_left as floor
from createPlasmidSamples import loadBPS, writeHeader

def initCumulativeProbList(speciesBPS):
	cumulativeProbList = []	
	for bpsTuple in speciesBPS:
		name, count, bps = bpsTuple
		print("Name:", name)
		probList = []
		total = 0
		for i,prob in enumerate(bps):
			total += prob
			cumulativeProbList.append(total)
		print("cumProbList:", probList)
		cumulativeProbList.append((name, probList))
	return cumulativeProbList
	
def choose(k, w, x, y, z):
	numer = fac(k)
	denom = fac(w)*fac(x)*fac(y)*fac(z)
	return numer // denom

def initializeBiasDict(k):
    index = 0
    bias = collections.OrderedDict()
    for A_count in range(k + 1):
        count = A_count

        for C_count in range(k + 1):
            count = A_count + C_count
            if count > k:
                break

            for G_count in range(k + 1):
                count = A_count + C_count + G_count
                if count > k:
                    break

	        for T_count in range(k + 1):
		    count = A_count + C_count + G_count + T_count
		    if count == k:
			bias[index] = choose(k, A_count,C_count,G_count,T_count) / float(4**k)
			index += 1
		    elif count > k:
			break
    return bias

def getSampleProb(cumProbList, num_reads, iterator):
	results = []
	for name, probList in cumProbList:
		bpsCounts = [0] * len(probList)
		for read in random.rand(num_reads):
			index = floor(probList, read)
			bpsCounts[index] += 1
		print("before normalization:",sampleProb)
		sampleBPS = [ bpsCounts[i] / float(num_reads) for i in range(len(bpsCounts)) ]
		print("after:",sampleProb)
		results.append((name, sampleProb))

	return results


def main(bpsPath, num_reads, num_training_samples, num_threads):

	speciesBPS = loadBPS(bpsPath)
	cumulativeProbList = initCumulativeProbList(speciesBPS)	
	bias = initializeBiasDict(10)
	
	pool = Pool(num_threads)
	func = partial(getSampleProb, cumulativeProbList, num_reads)
	results = pool.map(func, range(num_training_samples))
	pool.close()
	pool.join()
	
	for threadResult in results:
		for name, bps in threadResult:
			for i,freq in enumerate(bps):
				sys.stdout.write("%f\t" % (freq - bias[i]))
			sys.stdout.write("%s\n" % name)


if __name__ == "__main__":
	random.seed(1) #set seed for computational reproducibility

	bpsPath = sys.argv[1]
	num_reads = int(sys.argv[2])
	num_training_samples = int(sys.argv[3])
	num_threads = int(sys.argv[4])

	#initialize global variables
	bias = {}
	cumulativeProbList = {}
	
	main(bpsPath, num_reads, num_training_samples, num_threads)
